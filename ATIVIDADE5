David Souza RA 1977953

Virgilio RA 1973804

Marcela RA 1965877



# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12k0ip3_x8tgzpFxK9d2TdKlqLHZg5JNv
"""

# O grafo será representado por um dicionário onde a chave é o nó e o valor é uma lista dos seus vizinhos.
grafo = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

#A função dfs receberá o grafo, o nó inicial (inicio) e um conjunto para rastrear os nós já visitados.
def dfs(grafo, inicio, visitado=None):
    # Se visitado for None, inicializa como um conjunto vazio
    if visitado is None:
        visitado = set()

    # Marca o nó atual como visitado
    visitado.add(inicio)

    # Imprime o nó para mostrar a ordem de travessia
    print(inicio, end=' ')

    # Explora os vizinhos do nó atual
    # Para cada vizinho, se ele não foi visitado, chama recursivamente o DFS
    for proximo_no in grafo.get(inicio, []):
        if proximo_no not in visitado:
            dfs(grafo, proximo_no, visitado)

    # O retorno não é estritamente necessário para a travessia,
    # mas pode retornar o conjunto de visitados para uso posterior
    return visitado

def dfs_ciclo(u, grafo, visitado, pilha_recursao):
    """
    Função DFS auxiliar para detecção de ciclos em grafos direcionados.
    u: Nó atual
    """

    # 1. Marca o nó atual como visitado e o adiciona à pilha de recursão
    visitado.add(u)
    pilha_recursao.add(u)

    # 2. Explora os vizinhos
    for v in grafo.get(u, []):

        # CASO 1: VIZINHO EM CICLO
        # Se o vizinho já estiver na pilha de recursão, encontramos um ciclo.
        if v in pilha_recursao:
            print(f"CICLO DETECTADO! Aresta de '{u}' para '{v}' fecha o ciclo.")
            return True

        # CASO 2: VIZINHO NÃO VISITADO
        # Se o vizinho não foi visitado, chamamos o DFS recursivamente.
        if v not in visitado:
            if dfs_ciclo(v, grafo, visitado, pilha_recursao):
                return True # Propaga a descoberta do ciclo

    # 3. BACKTRACKING: Remove o nó da pilha de recursão ao sair
    # Significa que não há mais caminhos a serem explorados a partir deste nó.
    pilha_recursao.remove(u)

    return False

def detectar_ciclos(grafo):
    """
    Função principal para iniciar a detecção de ciclos em todos os nós.
    """
    visitado = set()
    pilha_recursao = set()

    # É necessário iterar sobre todos os nós para cobrir componentes desconectados
    for no in grafo:
        if no not in visitado:
            if dfs_ciclo(no, grafo, visitado, pilha_recursao):
                return True # Ciclo encontrado em qualquer componente

    return False

# Grafo Direcionado com um ciclo (B -> C -> D -> B)
grafo_direcionado_com_ciclo = {
    'A': ['B'],
    'B': ['C'],
    'C': ['D', 'E'],
    'D': ['B'], # Aresta que fecha o ciclo
    'E': ['F'],
    'F': ['G'],
    'G': []
}

# Grafo Direcionado Aclico (DAG)
grafo_direcionado_sem_ciclo = {
    '1': ['2', '3'],
    '2': ['4'],
    '3': ['4'],
    '4': ['5'],
    '5': []
}
