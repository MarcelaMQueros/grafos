# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i_NMTHw4YDk7ByuYsu_zBRPWOYvraJZW
"""

class GrafoListaAdjacencia:


    def __init__(self):
        self.lista_adj = {}

    def inserir_vertice(self, vertice):
        """Insere um novo vértice no grafo se ele não existir."""
        if vertice not in self.lista_adj:
            self.lista_adj[vertice] = set()
            print(f"Vértice '{vertice}' inserido.")
        else:
            print(f"Vértice '{vertice}' já existe.")

    def remover_vertice(self, vertice):
        """Remove um vértice e todas as arestas que o envolvem."""
        if vertice in self.lista_adj:
            # 1. Remove o vértice da lista principal
            del self.lista_adj[vertice]

            # 2. Remove todas as referências ao vértice nas listas de adjacência dos outros vértices
            for vizinhos in self.lista_adj.values():
                if vertice in vizinhos:
                    vizinhos.remove(vertice)
            print(f"Vértice '{vertice}' e todas as suas arestas removidas.")
        else:
            print(f"Vértice '{vertice}' não encontrado.")

    # --- Operações de Arestas ---

    def inserir_aresta(self, origem, destino):
        """Insere uma aresta direcionada de origem para destino."""
        if origem not in self.lista_adj:
            self.inserir_vertice(origem)
        if destino not in self.lista_adj:
            self.inserir_vertice(destino)

        # Adiciona o destino à lista de vizinhos da origem
        self.lista_adj[origem].add(destino)
        print(f"Aresta de '{origem}' para '{destino}' inserida.")

    def remover_aresta(self, origem, destino):
        """Remove a aresta direcionada de origem para destino."""
        if origem in self.lista_adj and destino in self.lista_adj[origem]:
            self.lista_adj[origem].remove(destino)
            print(f"Aresta de '{origem}' para '{destino}' removida.")
        else:
            print(f"Aresta de '{origem}' para '{destino}' não existe.")

    # --- Consultas e Cálculos ---

    def calcular_grau(self):
        """Calcula e exibe o grau de entrada (in-degree) e de saída (out-degree) de cada vértice."""
        # 1. Calcular Grau de Saída (Out-Degree)
        grau_saida = {v: len(vizinhos) for v, vizinhos in self.lista_adj.items()}

        # 2. Calcular Grau de Entrada (In-Degree)
        grau_entrada = {v: 0 for v in self.lista_adj}
        for vizinhos in self.lista_adj.values():
            for destino in vizinhos:
                if destino in grau_entrada:
                    grau_entrada[destino] += 1

        # 3. Exibir Resultados
        print("\n--- Grau de Cada Vértice (Grafo Direcionado) ---")
        for vertice in self.lista_adj:
            print(f"Vértice {vertice}:")
            print(f"  Grau de Saída (Out-Degree): {grau_saida.get(vertice, 0)}")
            print(f"  Grau de Entrada (In-Degree): {grau_entrada.get(vertice, 0)}")

    def verificar_aresta(self, origem, destino):
        """Verifica se existe uma aresta direta de origem para destino."""
        existe = origem in self.lista_adj and destino in self.lista_adj[origem]
        print(f"\nExiste aresta de '{origem}' para '{destino}'? {'Sim' if existe else 'Não'}")
        return existe

    def listar_vizinhos(self, vertice):
        """Lista todos os vizinhos de um vértice (o que o vértice aponta)."""
        if vertice in self.lista_adj:
            vizinhos = sorted(list(self.lista_adj[vertice]))
            print(f"\nVizinhos de '{vertice}': {vizinhos}")
            return vizinhos
        else:
            print(f"Vértice '{vertice}' não encontrado.")
            return []

    # --- Verificação de Percurso (Usando Busca em Largura - BFS) ---

    def verificar_percurso_possivel(self, inicio, fim):
        """
        Verifica se existe um caminho (percurso) de um vértice inicial para um final
        usando Busca em Largura (BFS).
        """
        if inicio == fim:
            print(f"\nPercurso de '{inicio}' para '{fim}': Sim (o próprio vértice)")
            return True

        if inicio not in self.lista_adj or fim not in self.lista_adj:
            print(f"\nPercurso de '{inicio}' para '{fim}': Não (um ou ambos vértices não existem)")
            return False

        fila = [inicio]
        visitados = {inicio}

        while fila:
            atual = fila.pop(0)

            for vizinho in self.lista_adj.get(atual, set()):
                if vizinho == fim:
                    print(f"\nPercurso de '{inicio}' para '{fim}': Sim (Caminho encontrado)")
                    return True

                if vizinho not in visitados:
                    visitados.add(vizinho)
                    fila.append(vizinho)

        print(f"\nPercurso de '{inicio}' para '{fim}': Não (Não há caminho)")
        return False

    def exibir_grafo(self):
        """Exibe a representação completa do grafo."""
        print("\n=== Representação do Grafo (Lista de Adjacência) ===")
        for vertice, vizinhos in self.lista_adj.items():
            print(f"Vértice {vertice}: -> {sorted(list(vizinhos))}")
        print("=====================================================")

# --- Demonstração de Uso do Algoritmo ---

grafo = GrafoListaAdjacencia()

# 1. Inserir Vértices
print("\n--- Teste de Inserção de Vértices ---")
grafo.inserir_vertice('A')
grafo.inserir_vertice('B')
grafo.inserir_vertice('C')
grafo.inserir_vertice('D')
grafo.inserir_vertice('E')

# 2. Inserir Arestas (e inserir um vértice junto com a aresta 'F')
print("\n--- Teste de Inserção de Arestas ---")
grafo.inserir_aresta('A', 'B')
grafo.inserir_aresta('B', 'C')
grafo.inserir_aresta('B', 'D')
grafo.inserir_aresta('C', 'E')
grafo.inserir_aresta('D', 'E')
grafo.inserir_aresta('E', 'B') # Cria um ciclo
grafo.inserir_aresta('A', 'F') # Insere 'F' automaticamente

grafo.exibir_grafo()

# 3. Listar Vizinhos
grafo.listar_vizinhos('B')
grafo.listar_vizinhos('E')

# 4. Verificar Aresta
grafo.verificar_aresta('A', 'B')
grafo.verificar_aresta('B', 'A') # Deve dar Não, pois é direcionado

# 5. Calcular Grau
grafo.calcular_grau()

# 6. Verificar Percurso
grafo.verificar_percurso_possivel('A', 'D')
grafo.verificar_percurso_possivel('D', 'C')
grafo.verificar_percurso_possivel('C', 'A') # Percurso impossível neste grafo

# 7. Remover Aresta
print("\n--- Teste de Remoção de Aresta ---")
grafo.remover_aresta('B', 'D')
grafo.listar_vizinhos('B')

# 8. Remover Vértice
print("\n--- Teste de Remoção de Vértice ---")
grafo.remover_vertice('E')
grafo.exibir_grafo()

grafo.calcular_grau()

class GrafoMatrizAdjacencia:
    """
    Implementação de um Grafo utilizando Matriz de Adjacência.
    As operações são projetadas para um grafo direcionado (dígrafo).
    """

    def __init__(self):
        # Mapeamento de nome do vértice (ex: 'A') para o índice da matriz (ex: 0)
        self.mapa_vertices = {}
        # Lista para armazenar os nomes dos vértices na ordem dos índices
        self.nomes_vertices = []
        # Matriz de Adjacência inicializada
        self.matriz_adj = []
        self.num_vertices = 0

    # --- Métodos Auxiliares ---

    def _get_index(self, vertice):
        """Retorna o índice do vértice na matriz."""
        return self.mapa_vertices.get(vertice, -1)

    def _redimensionar_matriz(self, novo_tamanho):
        """Redimensiona a matriz, preenchendo novos espaços com 0."""

        # Cria uma nova matriz vazia
        nova_matriz = [[0] * novo_tamanho for _ in range(novo_tamanho)]

        # Copia os valores da matriz antiga para a nova
        tamanho_antigo = self.num_vertices - 1 # O novo_tamanho já está com +1
        if tamanho_antigo >= 0:
            for i in range(tamanho_antigo):
                for j in range(tamanho_antigo):
                    nova_matriz[i][j] = self.matriz_adj[i][j]

        self.matriz_adj = nova_matriz

    # --- Operações de Vértices ---

    def inserir_vertice(self, vertice):
        """Insere um novo vértice no grafo e redimensiona a matriz."""
        if vertice not in self.mapa_vertices:
            # 1. Atualiza o mapeamento e a contagem
            indice = self.num_vertices
            self.num_vertices += 1
            self.mapa_vertices[vertice] = indice
            self.nomes_vertices.append(vertice)


            # 2. Redimensiona a matriz para o novo tamanho
            self._redimensionar_matriz(self.num_vertices)

            # Não é necessário imprimir no auxiliar, apenas na chamada principal
            # print(f"Vértice '{vertice}' inserido no índice {indice}.")
        else:
            print(f"Vértice '{vertice}' já existe.")

    def remover_vertice(self, vertice):
        """Remove um vértice e todas as suas arestas, reorganizando a matriz."""
        if vertice not in self.mapa_vertices:
            print(f"Vértice '{vertice}' não encontrado.")
            return

        idx_removido = self._get_index(vertice)

        # 1. Remove o nome e o mapeamento
        self.nomes_vertices.pop(idx_removido)
        del self.mapa_vertices[vertice]
        self.num_vertices -= 1

        # 2. Reconstroi/reorganiza a matriz, removendo a linha e coluna
        nova_matriz = []
        for i in range(len(self.matriz_adj)):
            if i != idx_removido:
                nova_linha = []
                for j in range(len(self.matriz_adj[i])):
                    if j != idx_removido:
                        nova_linha.append(self.matriz_adj[i][j])
                if nova_linha:
                    nova_matriz.append(nova_linha)

        self.matriz_adj = nova_matriz

        # 3. Atualiza os índices do mapeamento após a remoção
        self.mapa_vertices = {nome: i for i, nome in enumerate(self.nomes_vertices)}

        print(f"Vértice '{vertice}' e suas arestas removidos.")


    # --- Operações de Arestas ---

    def inserir_aresta(self, origem, destino):
        """Insere uma aresta direcionada de origem para destino (M[i][j] = 1)."""
        # Garante que os vértices existam
        if origem not in self.mapa_vertices: self.inserir_vertice(origem)
        if destino not in self.mapa_vertices: self.inserir_vertice(destino)

        idx_origem = self._get_index(origem)
        idx_destino = self._get_index(destino)

        # Marca a posição na matriz
        self.matriz_adj[idx_origem][idx_destino] = 1
        print(f"Aresta de '{origem}' para '{destino}' inserida.")

    def remover_aresta(self, origem, destino):
        """Remove a aresta direcionada de origem para destino (M[i][j] = 0)."""
        idx_origem = self._get_index(origem)
        idx_destino = self._get_index(destino)

        if idx_origem != -1 and idx_destino != -1 and self.matriz_adj[idx_origem][idx_destino] == 1:
            self.matriz_adj[idx_origem][idx_destino] = 0
            print(f"Aresta de '{origem}' para '{destino}' removida.")
        else:
            print(f"Aresta de '{origem}' para '{destino}' não existe ou vértices inválidos.")

    # --- Consultas e Cálculos ---

    def calcular_grau(self):
        """Calcula e exibe o grau de entrada (in-degree) e de saída (out-degree) de cada vértice."""

        print("\n--- Grau de Cada Vértice (Grafo Direcionado) ---")
        for i in range(self.num_vertices):
            vertice = self.nomes_vertices[i]

            # Grau de Saída (Out-Degree): Soma da Linha i
            grau_saida = sum(self.matriz_adj[i])

            # Grau de Entrada (In-Degree): Soma da Coluna i
            grau_entrada = sum(self.matriz_adj[j][i] for j in range(self.num_vertices))

            print(f"Vértice {vertice}:")
            print(f"  Grau de Saída (Out-Degree): {grau_saida}")
            print(f"  Grau de Entrada (In-Degree): {grau_entrada}")

    def verificar_aresta(self, origem, destino):
        """Verifica se existe uma aresta direta de origem para destino."""
        idx_origem = self._get_index(origem)
        idx_destino = self._get_index(destino)

        existe = False
        if idx_origem != -1 and idx_destino != -1:
            existe = self.matriz_adj[idx_origem][idx_destino] == 1

        print(f"\nExiste aresta de '{origem}' para '{destino}'? {'Sim' if existe else 'Não'}")
        return existe

    def listar_vizinhos(self, vertice):
        """Lista todos os vértices vizinhos (os que o vértice aponta)."""
        idx_origem = self._get_index(vertice)
        vizinhos = []

        if idx_origem != -1:
            # Percorre a linha do vértice de origem
            for j in range(self.num_vertices):
                if self.matriz_adj[idx_origem][j] == 1:
                    vizinhos.append(self.nomes_vertices[j])

            print(f"\nVizinhos de '{vertice}': {sorted(vizinhos)}")
            return vizinhos
        else:
            print(f"Vértice '{vertice}' não encontrado.")
            return []

    # --- Verificação de Percurso (Busca em Profundidade - DFS) ---

    def verificar_percurso_possivel(self, inicio, fim):
        """
        Verifica se existe um caminho (percurso) de um vértice inicial para um final
        usando Busca em Profundidade (DFS).
        """
        idx_inicio = self._get_index(inicio)
        idx_fim = self._get_index(fim)

        if idx_inicio == -1 or idx_fim == -1:
            print(f"\nPercurso de '{inicio}' para '{fim}': Não (um ou ambos vértices não existem)")
            return False

        if inicio == fim:
            print(f"\nPercurso de '{inicio}' para '{fim}': Sim (o próprio vértice)")
            return True

        # Pilha para DFS e conjunto de visitados
        pilha = [idx_inicio]
        visitados = {idx_inicio}

        while pilha:
            atual_idx = pilha.pop()

            # Percorre a linha do vértice atual para encontrar vizinhos
            for vizinho_idx in range(self.num_vertices):
                if self.matriz_adj[atual_idx][vizinho_idx] == 1:

                    if vizinho_idx == idx_fim:
                        print(f"\nPercurso de '{inicio}' para '{fim}': Sim (Caminho encontrado)")
                        return True

                    if vizinho_idx not in visitados:
                        visitados.add(vizinho_idx)
                        pilha.append(vizinho_idx)

        print(f"\nPercurso de '{inicio}' para '{fim}': Não (Não há caminho)")
        return False

    def exibir_grafo(self):
        """Exibe a representação completa do grafo."""
        print("\n=== Representação do Grafo (Matriz de Adjacência) ===")

        # Imprime o cabeçalho (nomes dos vértices)
        print("   " + " ".join(f"{v:^3}" for v in self.nomes_vertices))
        print("  " + "----" * self.num_vertices)

        # Imprime as linhas
        for i in range(self.num_vertices):
            nome_vertice = self.nomes_vertices[i]
            linha = " ".join(f"{self.matriz_adj[i][j]:^3}" for j in range(self.num_vertices))
            print(f"{nome_vertice} | {linha}")

        print("=====================================================")


# --- Demonstração de Uso do Algoritmo ---

grafo_matriz = GrafoMatrizAdjacencia()

print("--- Teste de Inserção de Vértices ---")
grafo_matriz.inserir_vertice('A')
grafo_matriz.inserir_vertice('B')
grafo_matriz.inserir_vertice('C')
grafo_matriz.inserir_vertice('D')

print("\n--- Teste de Inserção de Arestas ---")
grafo_matriz.inserir_aresta('A', 'B')
grafo_matriz.inserir_aresta('B', 'C')
grafo_matriz.inserir_aresta('C', 'A')
grafo_matriz.inserir_aresta('D', 'B')

grafo_matriz.exibir_grafo()

print("\n--- Teste de Listar Vizinhos ---")
grafo_matriz.listar_vizinhos('B')
grafo_matriz.listar_vizinhos('D')

print("\n--- Teste de Verificar Aresta ---")
grafo_matriz.verificar_aresta('B', 'C')
grafo_matriz.verificar_aresta('C', 'D')

print("\n--- Teste de Calcular Grau ---")
grafo_matriz.calcular_grau()

print("\n--- Teste de Verificar Percurso ---")
grafo_matriz.verificar_percurso_possivel('D', 'C')
grafo_matriz.verificar_percurso_possivel('C', 'D')

print("\n--- Teste de Remoção de Aresta ---")
grafo_matriz.remover_aresta('D', 'B')
grafo_matriz.verificar_aresta('D', 'B')

print("\n--- Teste de Remoção de Vértice ---")
grafo_matriz.remover_vertice('B')
grafo_matriz.exibir_grafo()
grafo_matriz.calcular_grau()

class GrafoListaArestas:
    """
    Implementação de um Grafo utilizando Lista de Arestas.
    O grafo é direcionado.
    """

    def __init__(self):
        # Conjunto (Set) para armazenar vértices únicos
        self.vertices = set()
        # Lista para armazenar as arestas (tuplas: (origem, destino))
        self.arestas = []

    # --- Operações de Vértices ---

    def inserir_vertice(self, vertice):
        """Insere um novo vértice no grafo."""
        if vertice not in self.vertices:
            self.vertices.add(vertice)
            print(f"Vértice '{vertice}' inserido.")
        else:
            print(f"Vértice '{vertice}' já existe.")

    def remover_vertice(self, vertice):
        """Remove um vértice e todas as arestas que o envolvem."""
        if vertice in self.vertices:
            # 1. Remove o vértice
            self.vertices.remove(vertice)

            # 2. Filtra a lista de arestas, removendo aquelas que usam o vértice
            self.arestas = [
                (origem, destino)
                for origem, destino in self.arestas
                if origem != vertice and destino != vertice
            ]
            print(f"Vértice '{vertice}' e todas as suas arestas removidos.")
        else:
            print(f"Vértice '{vertice}' não encontrado.")

    # --- Operações de Arestas ---

    def inserir_aresta(self, origem, destino):
        """Insere uma aresta direcionada (origem, destino)."""
        # Garante que os vértices existam
        self.inserir_vertice(origem)
        self.inserir_vertice(destino)

        aresta = (origem, destino)
        if aresta not in self.arestas:
            self.arestas.append(aresta)
            print(f"Aresta de '{origem}' para '{destino}' inserida.")
        else:
            print(f"Aresta de '{origem}' para '{destino}' já existe.")

    def remover_aresta(self, origem, destino):
        """Remove a aresta direcionada (origem, destino)."""
        aresta = (origem, destino)
        if aresta in self.arestas:
            self.arestas.remove(aresta)
            print(f"Aresta de '{origem}' para '{destino}' removida.")
        else:
            print(f"Aresta de '{origem}' para '{destino}' não existe.")

    # --- Consultas e Cálculos ---

    def calcular_grau(self):
        """Calcula e exibe o grau de entrada (in-degree) e de saída (out-degree) de cada vértice."""
        grau_entrada = {v: 0 for v in self.vertices}
        grau_saida = {v: 0 for v in self.vertices}

        # Percorre todas as arestas
        for origem, destino in self.arestas:
            if origem in grau_saida:
                grau_saida[origem] += 1
            if destino in grau_entrada:
                grau_entrada[destino] += 1

        print("\n--- Grau de Cada Vértice (Grafo Direcionado) ---")
        for vertice in sorted(list(self.vertices)):
            print(f"Vértice {vertice}:")
            print(f"  Grau de Saída (Out-Degree): {grau_saida.get(vertice, 0)}")
            print(f"  Grau de Entrada (In-Degree): {grau_entrada.get(vertice, 0)}")

    def verificar_aresta(self, origem, destino):
        """Verifica se existe uma aresta direta de origem para destino."""
        aresta = (origem, destino)
        existe = aresta in self.arestas
        print(f"\nExiste aresta de '{origem}' para '{destino}'? {'Sim' if existe else 'Não'}")
        return existe

    def listar_vizinhos(self, vertice):
        """Lista todos os vizinhos de um vértice (o que o vértice aponta)."""
        if vertice not in self.vertices:
            print(f"Vértice '{vertice}' não encontrado.")
            return []

        vizinhos = set()
        # Percorre todas as arestas e coleta os destinos onde a origem é o vértice dado
        for origem, destino in self.arestas:
            if origem == vertice:
                vizinhos.add(destino)

        vizinhos_lista = sorted(list(vizinhos))
        print(f"\nVizinhos de '{vertice}': {vizinhos_lista}")
        return vizinhos_lista

    # --- Verificação de Percurso (Usando Busca em Largura - BFS) ---

    def verificar_percurso_possivel(self, inicio, fim):
        """
        Verifica se existe um caminho (percurso) de um vértice inicial para um final
        usando Busca em Largura (BFS).
        """
        if inicio not in self.vertices or fim not in self.vertices:
            print(f"\nPercurso de '{inicio}' para '{fim}': Não (um ou ambos vértices não existem)")
            return False

        if inicio == fim:
            print(f"\nPercurso de '{inicio}' para '{fim}': Sim (o próprio vértice)")
            return True

        # Converte para uma lista de adjacência (necessário para BFS eficiente)
        adjacencia = {v: set() for v in self.vertices}
        for origem, destino in self.arestas:
            adjacencia[origem].add(destino)

        fila = [inicio]
        visitados = {inicio}

        while fila:
            atual = fila.pop(0)

            for vizinho in adjacencia.get(atual, set()):
                if vizinho == fim:
                    print(f"\nPercurso de '{inicio}' para '{fim}': Sim (Caminho encontrado)")
                    return True

                if vizinho not in visitados:
                    visitados.add(vizinho)
                    fila.append(vizinho)

        print(f"\nPercurso de '{inicio}' para '{fim}': Não (Não há caminho)")
        return False

    def exibir_grafo(self):
        """Exibe a representação completa do grafo."""
        print("\n=== Representação do Grafo (Lista de Arestas) ===")
        print(f"Vértices: {sorted(list(self.vertices))}")
        print(f"Arestas: {self.arestas}")
        print("=================================================")

# --- Demonstração de Uso do Algoritmo ---

grafo = GrafoListaArestas()

# 1. Inserir Vértices
print("\n--- Teste de Inserção de Vértices ---")
grafo.inserir_vertice('A')
grafo.inserir_vertice('B')
grafo.inserir_vertice('C')
grafo.inserir_vertice('D')

# 2. Inserir Arestas
print("\n--- Teste de Inserção de Arestas ---")
grafo.inserir_aresta('A', 'B')
grafo.inserir_aresta('B', 'C')
grafo.inserir_aresta('C', 'A')
grafo.inserir_aresta('D', 'B')
grafo.inserir_aresta('A', 'C') # Segunda aresta de A

grafo.exibir_grafo()

# 3. Listar Vizinhos
grafo.listar_vizinhos('A')
grafo.listar_vizinhos('D')

# 4. Verificar Aresta
grafo.verificar_aresta('A', 'B')
grafo.verificar_aresta('B', 'A') # Deve dar Não, pois é direcionado

# 5. Calcular Grau
grafo.calcular_grau()

# 6. Verificar Percurso
grafo.verificar_percurso_possivel('D', 'C') # D -> B -> C
grafo.verificar_percurso_possivel('C', 'D') # Impossível

# 7. Remover Aresta
print("\n--- Teste de Remoção de Aresta ---")
grafo.remover_aresta('D', 'B')
grafo.verificar_aresta('D', 'B')

# 8. Remover Vértice
print("\n--- Teste de Remoção de Vértice ---")
grafo.remover_vertice('A')
grafo.exibir_grafo()
grafo.calcular_grau()
