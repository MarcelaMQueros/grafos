# Marcela RA 1965877
# Virgilio RA 1973804
# David Souza RA 1977953

# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1383eo0chnF9PXUXLWgID01qzZtKJKvZy
"""

from collections import deque

class GrafoListaAdjacenciaBFS:
    """
    Implementação de um Grafo utilizando Lista de Adjacência
    e demonstração da Busca em Largura (BFS).
    """

    def __init__(self):
        # A lista de adjacência é um dicionário: {vertice: {vizinho1, vizinho2, ...}}
        self.lista_adj = {}

    def inserir_vertice(self, vertice):
        """Insere um novo vértice."""
        if vertice not in self.lista_adj:
            self.lista_adj[vertice] = set()

    def inserir_aresta(self, origem, destino, direcionado=True):
        """Insere uma aresta. Por padrão, o grafo é direcionado."""
        self.inserir_vertice(origem)
        self.inserir_vertice(destino)
        self.lista_adj[origem].add(destino)

        # Se não for direcionado, adiciona a aresta de volta
        if not direcionado:
            self.lista_adj[destino].add(origem)

    def busca_em_largura(self, inicio):
        """
        Executa a Busca em Largura (BFS) a partir de um vértice inicial.
        Retorna a ordem de visita e imprime o processo.
        """
        if inicio not in self.lista_adj:
            print(f"Erro: Vértice inicial '{inicio}' não encontrado no grafo.")
            return []

        # Fila (Queue) para armazenar os vértices a serem visitados (usamos deque para eficiência)
        fila = deque([inicio])

        # Conjunto para rastrear os vértices já visitados
        visitados = {inicio}

        # Lista para armazenar a ordem final da travessia
        ordem_visita = []

        print(f"\n--- Início da Busca em Largura (BFS) a partir de '{inicio}' ---")

        while fila:
            # 1. Desenfileirar o vértice atual
            vertice_atual = fila.popleft()
            ordem_visita.append(vertice_atual)
            print(f"Visitando: {vertice_atual}")

            # 2. Explorar os vizinhos
            # Ordenamos os vizinhos para garantir uma saída previsível na demonstração
            for vizinho in sorted(list(self.lista_adj.get(vertice_atual, set()))):
                if vizinho not in visitados:
                    # 3. Marcar como visitado e enfileirar
                    visitados.add(vizinho)
                    fila.append(vizinho)
                    print(f"  Enfileirando vizinho: {vizinho}")

        print(f"\nBusca em Largura (BFS) concluída. Ordem: {ordem_visita}")
        return ordem_visita

# --- Demonstração de Uso ---

grafo_exemplo = GrafoListaAdjacenciaBFS()

# Inserindo arestas (Grafo não-direcionado para melhor visualização da travessia)
grafo_exemplo.inserir_aresta('A', 'B', direcionado=False)
grafo_exemplo.inserir_aresta('A', 'C', direcionado=False)
grafo_exemplo.inserir_aresta('B', 'D', direcionado=False)
grafo_exemplo.inserir_aresta('C', 'E', direcionado=False)
grafo_exemplo.inserir_aresta('D', 'F', direcionado=False)
grafo_exemplo.inserir_aresta('E', 'G', direcionado=False)
grafo_exemplo.inserir_aresta('F', 'H', direcionado=False) # H isolado do resto
grafo_exemplo.inserir_aresta('G', 'H', direcionado=False)

# Adicionando um vértice isolado (que não será visitado na travessia principal)
grafo_exemplo.inserir_vertice('Z')

# Executando o algoritmo a partir do vértice 'A'
grafo_exemplo.busca_em_largura('A')

from collections import deque

class GrafoMenorCaminhoBFS:
    """
    Implementação de um Grafo utilizando Lista de Adjacência
    e demonstração do algoritmo de Menor Caminho (Shortest Path) com BFS.
    """

    def __init__(self):
        # Lista de adjacência: {vertice: {vizinho1, vizinho2, ...}}
        self.lista_adj = {}

    def inserir_vertice(self, vertice):
        """Insere um novo vértice."""
        if vertice not in self.lista_adj:
            self.lista_adj[vertice] = set()

    def inserir_aresta(self, origem, destino, direcionado=False):
        """Insere uma aresta. O padrão é não-direcionado (ideal para menor caminho)."""
        self.inserir_vertice(origem)
        self.inserir_vertice(destino)
        self.lista_adj[origem].add(destino)

        # Para grafo não-ponderado, é comum usar não-direcionado para menor caminho
        if not direcionado:
            self.lista_adj[destino].add(origem)

    def _reconstruir_caminho(self, predecessores, inicio, fim):
        """Função auxiliar para reconstruir o caminho a partir do mapa de predecessores."""
        caminho = deque()
        atual = fim

        # Volta do fim para o início usando o mapa de predecessores
        while atual is not None:
            caminho.appendleft(atual)
            # O predecessor do 'início' é None, encerrando o loop
            atual = predecessores.get(atual)

        # Verifica se o caminho foi de fato do início ao fim
        if caminho[0] == inicio:
            return list(caminho)
        return None # Indica que não foi possível atingir o destino

    def encontrar_menor_caminho(self, inicio, fim):
        """
        Encontra o caminho mais curto (em número de arestas) entre dois vértices
        em um grafo não-ponderado usando BFS.
        """
        if inicio not in self.lista_adj or fim not in self.lista_adj:
            print(f"\nErro: Vértice de início '{inicio}' ou de fim '{fim}' não está no grafo.")
            return None

        if inicio == fim:
            return [inicio]

        # Fila para BFS
        fila = deque([inicio])

        # Dicionário para rastrear o predecessor de cada nó no caminho mais curto
        # predecessor[vertice] = vertice_anterior
        predecessores = {inicio: None}

        print(f"\n--- Buscando o Caminho mais Curto de '{inicio}' para '{fim}' ---")

        while fila:
            vertice_atual = fila.popleft()

            # Explora os vizinhos do vértice atual
            for vizinho in sorted(list(self.lista_adj.get(vertice_atual, set()))):
                # Se o vizinho ainda não foi visitado/processado
                if vizinho not in predecessores:
                    # Marca o vertice_atual como predecessor do vizinho
                    predecessores[vizinho] = vertice_atual
                    fila.append(vizinho)

                    # Se encontrou o destino, o caminho encontrado é o mais curto
                    if vizinho == fim:
                        caminho = self._reconstruir_caminho(predecessores, inicio, fim)
                        print("Caminho encontrado!")
                        print(f"Menor Caminho ({len(caminho) - 1} arestas): {caminho}")
                        return caminho

        # Se a fila esvaziou e o destino não foi encontrado
        print(f"Não foi encontrado nenhum caminho de '{inicio}' para '{fim}'.")
        return None

# --- Demonstração de Uso ---

grafo_caminho = GrafoMenorCaminhoBFS()

# Inserindo arestas (Grafo de 8 vértices)
grafo_caminho.inserir_aresta('A', 'B')
grafo_caminho.inserir_aresta('A', 'C')
grafo_caminho.inserir_aresta('B', 'D')
grafo_caminho.inserir_aresta('C', 'E')
grafo_caminho.inserir_aresta('D', 'F')
grafo_caminho.inserir_aresta('E', 'F') # Conexão direta (Curto)
grafo_caminho.inserir_aresta('F', 'G')

# Exemplo de um caminho longo de A para G: A -> B -> D -> F -> G (4 arestas)
# Exemplo de um caminho curto de A para G: A -> C -> E
